<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Organization Transformation Through Communication Evolution</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: linear-gradient(135deg, #4C32CC 0%, #6B46C1 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            overflow-x: hidden;
            padding: 10px;
            gap: 20px;
        }

        .container {
            width: min(98vw, 1400px);
            height: min(98vh, 1000px);
            min-height: 700px;
            background: rgba(255, 255, 255, 0.98);
            border-radius: 24px;
            box-shadow: 0 25px 70px rgba(0, 0, 0, 0.4);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            margin: 0 auto;
        }

        .logo-container {
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        .main-logo {
            height: 64px;
            transition: transform 0.3s ease;
            margin-top: 20px;
        }
        
        .main-logo:hover {
            transform: scale(1.05);
        }

        .header {
            padding: 20px 30px;
            background: linear-gradient(135deg, #4C32CC 0%, #6B46C1 100%);
            color: white;
            text-align: center;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 88px;
        }

        .header::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            animation: shimmer 10s linear infinite;
        }

        @keyframes shimmer {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .header h1 {
            font-size: 1.8em;
            margin-bottom: 6px;
            position: relative;
            z-index: 1;
            font-weight: 600;
            letter-spacing: -0.5px;
            line-height: 1.2;
            max-width: 90%;
        }

        .header p {
            font-size: 1em;
            opacity: 0.95;
            position: relative;
            z-index: 1;
            font-weight: 300;
        }

        .content {
            flex: 1;
            display: flex;
            padding: 20px;
            gap: 20px;
            background: #f8f9fa;
            min-height: 0;
        }

        .visualization {
            flex: 2;
            position: relative;
            background: #fafafa;
            border-radius: 16px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
        }

        .controls {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-width: 380px;
            min-width: 280px;
            overflow-y: auto;
            overflow-x: visible;
            padding-right: 10px;
            max-height: calc(100vh - 220px);
        }

        .phase-card {
            background: white;
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 3px 12px rgba(0, 0, 0, 0.08);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            border: 2px solid transparent;
            position: relative;
            overflow: hidden;
            flex-shrink: 0;
            word-wrap: break-word;
        }

        .phase-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(76, 50, 204, 0.05), transparent);
            transition: left 0.5s ease;
        }

        .phase-card:hover::before {
            left: 100%;
        }

        .phase-card.active {
            border-color: #4C32CC;
            /* transform: scale(1.02); */
            box-shadow: 0 8px 25px rgba(76, 50, 204, 0.2);
            background: linear-gradient(135deg, white 0%, #f3f0ff 100%);
        }

        .phase-card h3 {
            color: #1a1a1a;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 1.05em;
            font-weight: 600;
        }

        .phase-card .icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #4C32CC 0%, #6B46C1 100%);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 0.9em;
            flex-shrink: 0;
        }

        .phase-card.active .icon {
            animation: iconPulse 2s ease-in-out infinite;
        }

        @keyframes iconPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }

        .phase-card .feature-tag {
            background: #f3f0ff;
            color: #4C32CC;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.75em;
            font-weight: 600;
            margin-left: auto;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .phase-card.active .feature-tag {
            background: #4C32CC;
            color: white;
        }

        .phase-card p {
            color: #555;
            font-size: 0.85em;
            line-height: 1.6;
            margin-top: 4px;
        }

        .metrics {
            background: white;
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 3px 12px rgba(0, 0, 0, 0.08);
            flex-shrink: 0;
            overflow: hidden;
        }

        .metrics h3 {
            color: #1a1a1a;
            margin-bottom: 15px;
            font-size: 1.1em;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .metrics-icon {
            width: 24px;
            height: 24px;
            background: linear-gradient(135deg, #4C32CC 0%, #6B46C1 100%);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.8em;
        }

        .metric-item {
            display: flex;
            align-items: center;
            margin-bottom: 14px;
        }

        .metric-label {
            min-width: 70px;
            font-size: 0.85em;
            color: #666;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .metric-bar {
            flex: 1;
            height: 10px;
            background: #e8e8e8;
            border-radius: 5px;
            margin: 0 10px;
            overflow: hidden;
            position: relative;
        }

        .metric-fill {
            height: 100%;
            background: linear-gradient(90deg, #4C32CC 0%, #6B46C1 100%);
            border-radius: 5px;
            transition: width 1.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .metric-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
            animation: metricShine 2s ease-in-out infinite;
        }

        @keyframes metricShine {
            0% { left: -100%; }
            50%, 100% { left: 100%; }
        }

        .metric-value {
            font-weight: 600;
            color: #4C32CC;
            min-width: 45px;
            text-align: right;
            font-size: 0.9em;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .overlay-info {
            position: absolute;
            top: 20px;
            left: 20px;
            background: white;
            padding: 15px 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            max-width: 250px;
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .overlay-info.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .overlay-info h4 {
            color: #1a1a1a;
            margin-bottom: 12px;
            font-size: 1em;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .overlay-icon {
            width: 24px;
            height: 24px;
            background: linear-gradient(135deg, #4C32CC 0%, #6B46C1 100%);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.7em;
        }

        .info-item {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            margin-bottom: 8px;
            font-size: 0.85em;
            color: #555;
            line-height: 1.4;
        }

        .info-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #4C32CC;
            margin-top: 5px;
            flex-shrink: 0;
        }

        .button-container {
            padding: 20px;
            text-align: center;
            background: #f8f9fa;
        }

        .play-button {
            background: linear-gradient(135deg, #4C32CC 0%, #6B46C1 100%);
            color: white;
            border: none;
            padding: 14px 36px;
            border-radius: 28px;
            font-size: 1em;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 4px 15px rgba(76, 50, 204, 0.3);
            position: relative;
            overflow: hidden;
        }

        .play-button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .play-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(76, 50, 204, 0.4);
        }

        .play-button:active::before {
            width: 300px;
            height: 300px;
        }
        
        .play-button:disabled {
            opacity: 0.7;
            cursor: not-allowed;
        }

        .legend {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: white;
            padding: 12px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            font-size: 0.75em;
            opacity: 0.9;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
        }

        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        /* Responsive Design */
        @media (max-width: 1024px) {
            .container {
                height: auto;
                min-height: 100vh;
            }
            
            .content {
                flex-direction: column;
                gap: 15px;
                min-height: auto;
            }
            
            .controls {
                flex: none;
                max-width: none;
                min-width: auto;
                max-height: none;
                flex-direction: row;
                padding-bottom: 10px;
                overflow: visible;
            }
            
            .phase-card {
                min-width: 200px;
                flex-shrink: 0;
                overflow: visible;
            }
            
            .metrics {
                min-width: 250px;
                flex-shrink: 0;
            }
            
            .main-logo {
                height: 64px;
            }

            .header {
                padding: 18px 25px;
            }
            
            .header h1 {
                font-size: 1.7em;
            }
            
            .overlay-info {
                max-width: 200px;
                padding: 12px 15px;
            }
        }

        @media (max-width: 768px) {
            body {
                padding: 5px;
                gap: 15px;
            }
            
            .container {
                width: 100vw;
                height: auto;
                border-radius: 0;
                min-height: auto;
                max-height: calc(100vh - 100px);
            }
            
            .main-logo {
                height: 56px;
            }

            .header {
                padding: 20px 15px;
            }
            
            .header h1 {
                font-size: 1.4em;
            }
            
            .header p {
                font-size: 1em;
            }
            
            .content {
                padding: 15px;
            }
            
            .controls {
                gap: 10px;
            }
            
            .phase-card {
                padding: 15px;
                min-width: 180px;
            }
            
            .phase-card h3 {
                font-size: 0.95em;
            }
            
            .phase-card p {
                font-size: 0.8em;
            }
            
            .metrics {
                padding: 15px;
                min-width: 200px;
            }
            
            .metric-label {
                min-width: 60px;
                font-size: 0.8em;
            }
            
            .overlay-info {
                position: relative;
                top: auto;
                left: auto;
                margin-bottom: 10px;
                max-width: none;
            }
            
            .legend {
                position: relative;
                bottom: auto;
                right: auto;
                margin-top: 10px;
                width: 100%;
                display: flex;
                flex-wrap: wrap;
                gap: 10px;
            }
            
            .button-container {
                padding: 15px;
            }
            
            .play-button {
                padding: 12px 24px;
                font-size: 0.9em;
            }
        }

        @media (max-width: 480px) {
            .header h1 {
                font-size: 1.3em;
            }
            
            .phase-card {
                min-width: 160px;
                padding: 12px;
            }
            
            .phase-card .icon {
                width: 28px;
                height: 28px;
                font-size: 0.8em;
            }
            
            .metrics {
                min-width: 180px;
                padding: 12px;
            }
            
            .metric-item {
                margin-bottom: 10px;
            }
            
            .metric-bar {
                height: 6px;
                margin: 0 8px;
            }
            
            .metric-value {
                min-width: 35px;
                font-size: 0.8em;
            }
        }
    </style>
</head>
<body>
    
    <div class="container">
        <div class="header">
            <h1>Transforming Organizations Through Communication Design</h1>
            <p>A strategic journey: Building feedback systems → Aligning values → Cultivating emotional intelligence</p>
        </div>
        
        <div class="content">
            <div class="visualization">
                <canvas id="networkCanvas"></canvas>
                
                <div class="overlay-info" id="silosOverlay">
                    <h4><span class="overlay-icon">📋</span>Current State</h4>
                    <div class="info-item">
                        <div class="info-dot" style="background: #FF9800"></div>
                        <span>Department-centric structure</span>
                    </div>
                    <div class="info-item">
                        <div class="info-dot" style="background: #FF9800"></div>
                        <span>Hierarchical information flow</span>
                    </div>
                    <div class="info-item">
                        <div class="info-dot" style="background: #FF9800"></div>
                        <span>Limited visibility across teams</span>
                    </div>
                    <div class="info-item">
                        <div class="info-dot" style="background: #FF9800"></div>
                        <span>Opportunity for enhanced collaboration</span>
                    </div>
                </div>
                
                <div class="overlay-info" id="feedbackOverlay">
                    <h4><span class="overlay-icon">💬</span>Communication Flow</h4>
                    <div class="info-item">
                        <div class="info-dot" style="background: #4CAF50"></div>
                        <span>Regular 1:1 conversations</span>
                    </div>
                    <div class="info-item">
                        <div class="info-dot" style="background: #FF9800"></div>
                        <span>Peer-to-peer recognition</span>
                    </div>
                    <div class="info-item">
                        <div class="info-dot" style="background: #2196F3"></div>
                        <span>360° feedback cycles</span>
                    </div>
                    <div class="info-item">
                        <div class="info-dot" style="background: #9C27B0"></div>
                        <span>Cross-level dialogues</span>
                    </div>
                </div>

                <div class="overlay-info" id="valuesOverlay">
                    <h4><span class="overlay-icon">🎯</span>Purpose Integration</h4>
                    <div class="info-item">
                        <div class="info-dot"></div>
                        <span>Teams unite around shared purpose</span>
                    </div>
                    <div class="info-item">
                        <div class="info-dot"></div>
                        <span>Values guide decision-making</span>
                    </div>
                    <div class="info-item">
                        <div class="info-dot"></div>
                        <span>Innovation hubs emerge naturally</span>
                    </div>
                    <div class="info-item">
                        <div class="info-dot"></div>
                        <span>Trust strengthens across boundaries</span>
                    </div>
                </div>

                <div class="overlay-info" id="eqOverlay">
                    <h4><span class="overlay-icon">🌟</span>Cultural Evolution</h4>
                    <div class="info-item">
                        <div class="info-dot" style="background: #E91E63"></div>
                        <span>Active listening as core competency</span>
                    </div>
                    <div class="info-item">
                        <div class="info-dot" style="background: #00BCD4"></div>
                        <span>Empathy-driven leadership</span>
                    </div>
                    <div class="info-item">
                        <div class="info-dot" style="background: #8BC34A"></div>
                        <span>Constructive conflict resolution</span>
                    </div>
                    <div class="info-item">
                        <div class="info-dot" style="background: #FFC107"></div>
                        <span>Innovation through psychological safety</span>
                    </div>
                </div>

                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #4C32CC"></div>
                        <span>Leadership</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #6B46C1"></div>
                        <span>Team Members</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #4CAF50"></div>
                        <span>Values Hubs</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #FF9800"></div>
                        <span>Feedback Loops</span>
                    </div>
                </div>
            </div>
            
            <div class="controls">
                <div class="phase-card active" data-phase="1">
                    <h3>
                        <span class="icon">1</span>
                        Traditional Structure
                        <span class="feature-tag">Default</span>
                    </h3>
                    <p>Hierarchical departments with limited cross-team collaboration and vertical information flow.</p>
                </div>
                
                <div class="phase-card" data-phase="2">
                    <h3>
                        <span class="icon">2</span>
                        Feedback Systems
                        <span class="feature-tag">+Communication</span>
                    </h3>
                    <p>Regular 1:1s, peer recognition, and 360° feedback create multi-directional communication.</p>
                </div>
                
                <div class="phase-card" data-phase="3">
                    <h3>
                        <span class="icon">3</span>
                        Values Alignment
                        <span class="feature-tag">+Purpose</span>
                    </h3>
                    <p>Teams unite around shared values, accelerating cross-functional collaboration through common goals.</p>
                </div>
                
                <div class="phase-card" data-phase="4">
                    <h3>
                        <span class="icon">4</span>
                        Adaptive Culture
                        <span class="feature-tag">+Intelligence</span>
                    </h3>
                    <p>Emotional intelligence embedded in daily interactions drives empathy, innovation, and rapid adaptation.</p>
                </div>
                
                <div class="metrics">
                    <h3><span class="metrics-icon">📊</span>Performance Metrics</h3>
                    <div class="metric-item">
                        <span class="metric-label">Trust</span>
                        <div class="metric-bar">
                            <div class="metric-fill" id="trustBar" style="width: 15%"></div>
                        </div>
                        <span class="metric-value" id="trustValue">15%</span>
                    </div>
                    <div class="metric-item">
                        <span class="metric-label">Collaboration</span>
                        <div class="metric-bar">
                            <div class="metric-fill" id="collaborationBar" style="width: 20%"></div>
                        </div>
                        <span class="metric-value" id="collaborationValue">20%</span>
                    </div>
                    <div class="metric-item">
                        <span class="metric-label">Engagement</span>
                        <div class="metric-bar">
                            <div class="metric-fill" id="engagementBar" style="width: 25%"></div>
                        </div>
                        <span class="metric-value" id="engagementValue">25%</span>
                    </div>
                    <div class="metric-item">
                        <span class="metric-label">Performance</span>
                        <div class="metric-bar">
                            <div class="metric-fill" id="performanceBar" style="width: 30%"></div>
                        </div>
                        <span class="metric-value" id="performanceValue">30%</span>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="button-container">
            <button class="play-button" onclick="playAnimation()">▶ View Complete Transformation</button>
        </div>
        
    </div>

    <div class="footer">
        <div class="logo-container">
            <img src="logo_happily_dark.png" alt="Happily" class="main-logo" />
        </div>
    </div>

    <script>
        const canvas = document.getElementById('networkCanvas');
        const ctx = canvas.getContext('2d');
        let animationId;
        let currentPhase = 1;
        let nodes = [];
        let connections = [];
        let particles = [];
        let feedbackLoops = [];
        let time = 0;

        // Resize canvas with device pixel ratio support
        function resizeCanvas() {
            const rect = canvas.parentElement.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            
            // Save the current transformation matrix
            ctx.save();
            
            // Set actual size in memory (scaled for retina displays)
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            
            // Scale back down using CSS
            canvas.style.width = rect.width + 'px';
            canvas.style.height = rect.height + 'px';
            
            // Restore the transformation matrix
            ctx.restore();
            
            // Scale context to ensure correct drawing operations
            ctx.scale(dpr, dpr);
            
            // Store dimensions for calculations
            canvas.displayWidth = rect.width;
            canvas.displayHeight = rect.height;
        }
        
        let resizeTimeout;
        function handleResize() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                resizeCanvas();
                // Reinitialize current phase to reposition nodes for new canvas size
                if (typeof setPhase === 'function') {
                    setPhase(currentPhase);
                }
            }, 250);
        }
        
        resizeCanvas();
        window.addEventListener('resize', handleResize);

        // Node class
        class Node {
            constructor(x, y, type, subtype = '', department = '') {
                this.x = x;
                this.y = y;
                this.targetX = x;
                this.targetY = y;
                this.vx = 0;
                this.vy = 0;
                this.type = type; // 'leader', 'member', 'values-hub', 'feedback-node'
                this.subtype = subtype;
                this.department = department;
                this.radius = this.getRadius();
                this.color = this.getColor();
                this.connections = [];
                this.pulsePhase = Math.random() * Math.PI * 2;
                this.eqLevel = 0;
            }

            getRadius() {
                switch(this.type) {
                    case 'leader': return 10;
                    case 'values-hub': return 12;
                    case 'feedback-node': return 8;
                    default: return 6;
                }
            }

            getColor() {
                switch(this.type) {
                    case 'leader': return '#4C32CC';
                    case 'values-hub': return '#4CAF50';
                    case 'feedback-node': return '#FF9800';
                    default: return '#6B46C1';
                }
            }

            update() {
                const dx = this.targetX - this.x;
                const dy = this.targetY - this.y;
                this.vx = this.vx * 0.88 + dx * 0.12;
                this.vy = this.vy * 0.88 + dy * 0.12;
                this.x += this.vx;
                this.y += this.vy;
            }

            draw() {
                const pulse = Math.sin(time * 0.02 + this.pulsePhase) * 0.1 + 1;
                const radius = this.radius * pulse;

                // Glow effect for high EQ nodes
                if (this.eqLevel > 0) {
                    const glowRadius = radius * (2 + this.eqLevel * 0.5);
                    const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, glowRadius);
                    gradient.addColorStop(0, this.color + '40');
                    gradient.addColorStop(1, 'transparent');
                    ctx.fillStyle = gradient;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, glowRadius, 0, Math.PI * 2);
                    ctx.fill();
                }

                // Node shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.beginPath();
                ctx.arc(this.x + 2, this.y + 2, radius, 0, Math.PI * 2);
                ctx.fill();

                // Node
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, radius, 0, Math.PI * 2);
                ctx.fill();

                // Inner ring for special nodes
                if (this.type === 'values-hub' || this.type === 'feedback-node') {
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, radius - 2, 0, Math.PI * 2);
                    ctx.stroke();
                }
            }
        }

        // Connection class
        class Connection {
            constructor(node1, node2, type = 'normal', strength = 0.5) {
                this.node1 = node1;
                this.node2 = node2;
                this.type = type; // 'normal', 'values', 'feedback', 'eq'
                this.strength = strength;
                this.particleTimer = 0;
                this.active = true;
                this.color = this.getColor();
            }

            getColor() {
                switch(this.type) {
                    case 'values': return '#4CAF50';
                    case 'feedback': return '#FF9800';
                    case 'eq': return '#E91E63';
                    default: return '#6B46C1';
                }
            }

            update() {
                this.particleTimer++;
                if (this.particleTimer % (40 - Math.floor(this.strength * 20)) === 0 && this.active) {
                    particles.push(new Particle(this.node1, this.node2, this.type));
                }
            }

            draw() {
                if (!this.active) return;
                
                const opacity = this.strength * 0.4;
                ctx.strokeStyle = this.color + Math.floor(opacity * 255).toString(16).padStart(2, '0');
                ctx.lineWidth = this.strength * 3;
                
                // Draw dashed line for feedback connections
                if (this.type === 'feedback') {
                    ctx.setLineDash([5, 5]);
                } else {
                    ctx.setLineDash([]);
                }
                
                ctx.beginPath();
                ctx.moveTo(this.node1.x, this.node1.y);
                
                // Curved lines for EQ connections
                if (this.type === 'eq') {
                    const midX = (this.node1.x + this.node2.x) / 2;
                    const midY = (this.node1.y + this.node2.y) / 2;
                    const offset = Math.sin(time * 0.01) * 20;
                    ctx.quadraticCurveTo(midX + offset, midY - offset, this.node2.x, this.node2.y);
                } else {
                    ctx.lineTo(this.node2.x, this.node2.y);
                }
                
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }

        // Particle class
        class Particle {
            constructor(startNode, endNode, type = 'normal') {
                this.startNode = startNode;
                this.endNode = endNode;
                this.progress = 0;
                this.speed = 0.015 + Math.random() * 0.015;
                this.size = 2 + Math.random() * 2;
                this.type = type;
                this.trail = [];
            }

            update() {
                this.progress += this.speed;
                
                const x = this.startNode.x + (this.endNode.x - this.startNode.x) * this.progress;
                const y = this.startNode.y + (this.endNode.y - this.startNode.y) * this.progress;
                
                this.trail.push({x, y, alpha: 1});
                if (this.trail.length > 5) {
                    this.trail.shift();
                }
                
                this.trail.forEach((point, i) => {
                    point.alpha = (i + 1) / this.trail.length;
                });
                
                return this.progress < 1;
            }

            draw() {
                // Draw trail
                this.trail.forEach((point, i) => {
                    ctx.fillStyle = `rgba(255, 255, 255, ${point.alpha * 0.3})`;
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, this.size * 0.5, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // Draw main particle
                const x = this.startNode.x + (this.endNode.x - this.startNode.x) * this.progress;
                const y = this.startNode.y + (this.endNode.y - this.startNode.y) * this.progress;
                
                const gradient = ctx.createRadialGradient(x, y, 0, x, y, this.size);
                gradient.addColorStop(0, 'rgba(255, 255, 255, 0.9)');
                gradient.addColorStop(1, this.getParticleColor());
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(x, y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }

            getParticleColor() {
                switch(this.type) {
                    case 'values': return 'rgba(76, 175, 80, 0.4)';
                    case 'feedback': return 'rgba(255, 152, 0, 0.4)';
                    case 'eq': return 'rgba(233, 30, 99, 0.4)';
                    default: return 'rgba(107, 70, 193, 0.4)';
                }
            }
        }

        // FeedbackLoop class for visual feedback indicators
        class FeedbackLoop {
            constructor(node1, node2, type) {
                this.node1 = node1;
                this.node2 = node2;
                this.type = type; // '1:1', 'peer', '360', 'skip'
                this.animPhase = Math.random() * Math.PI * 2;
            }

            draw() {
                const midX = (this.node1.x + this.node2.x) / 2;
                const midY = (this.node1.y + this.node2.y) / 2;
                const pulse = Math.sin(time * 0.03 + this.animPhase) * 0.3 + 0.7;
                
                ctx.save();
                ctx.globalAlpha = pulse * 0.6;
                
                // Draw feedback indicator
                ctx.fillStyle = '#FF9800';
                ctx.beginPath();
                ctx.arc(midX, midY, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw arrows for bidirectional feedback
                if (this.type === 'peer' || this.type === '360') {
                    ctx.strokeStyle = '#FF9800';
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    // Arrow pointing to node2
                    ctx.moveTo(midX - 6, midY - 3);
                    ctx.lineTo(midX - 3, midY);
                    ctx.lineTo(midX - 6, midY + 3);
                    // Arrow pointing to node1
                    ctx.moveTo(midX + 6, midY - 3);
                    ctx.lineTo(midX + 3, midY);
                    ctx.lineTo(midX + 6, midY + 3);
                    ctx.stroke();
                }
                
                ctx.restore();
            }
        }

        // Initialize Phase 1: Dysfunctional Silos
        function initPhase1() {
            nodes = [];
            connections = [];
            particles = [];
            feedbackLoops = [];
            

            
            const centerX = (canvas.displayWidth || canvas.width) / 2;
            const centerY = (canvas.displayHeight || canvas.height) / 2;
            const departments = ['Engineering', 'Sales', 'Marketing', 'Operations', 'HR'];
            const angleStep = (Math.PI * 2) / departments.length;
            
            departments.forEach((dept, deptIndex) => {
                const deptAngle = angleStep * deptIndex - Math.PI / 2;
                const deptX = centerX + Math.cos(deptAngle) * 180;
                const deptY = centerY + Math.sin(deptAngle) * 180;
                
                // Create department cluster - hierarchical structure
                const leaderNode = new Node(deptX, deptY, 'leader', '', dept);
                nodes.push(leaderNode);
                
                // Add team members in a hierarchical layout
                for (let i = 0; i < 5; i++) {
                    const angle = (Math.PI * 2 / 5) * i;
                    const radius = 50;
                    const x = deptX + Math.cos(angle) * radius;
                    const y = deptY + Math.sin(angle) * radius;
                    const memberNode = new Node(x, y, 'member', '', dept);
                    nodes.push(memberNode);
                    
                    // Only connect to leader (hierarchical)
                    connections.push(new Connection(leaderNode, memberNode, 'normal', 0.3));
                }
            });
            
            setTimeout(() => updateMetrics(15, 20, 25, 30), 100);
        }

        // Phase 2: Enhanced Feedback Loops (was Phase 3)
        function initPhase2() {
            // Animate the transition more smoothly
            setTimeout(() => {
                // Add feedback nodes and connections
                const leaders = nodes.filter(n => n.type === 'leader');
                const members = nodes.filter(n => n.type === 'member');
            
            // Manager-report 1:1s
            leaders.forEach(leader => {
                const reports = members.filter(m => 
                    Math.abs(m.x - leader.x) < 100 && Math.abs(m.y - leader.y) < 100
                );
                reports.forEach(report => {
                    connections.push(new Connection(leader, report, 'feedback', 0.6));
                    feedbackLoops.push(new FeedbackLoop(leader, report, '1:1'));
                });
            });
            
            // Peer recognition systems
            for (let i = 0; i < members.length; i++) {
                for (let j = i + 1; j < members.length; j++) {
                    if (Math.random() > 0.7) {
                        connections.push(new Connection(members[i], members[j], 'feedback', 0.4));
                        feedbackLoops.push(new FeedbackLoop(members[i], members[j], 'peer'));
                    }
                }
            }
            
            // 360 feedback loops
            nodes.forEach(node => {
                if (Math.random() > 0.8) {
                    const feedbackNode = new Node(
                        node.x + (Math.random() - 0.5) * 30,
                        node.y + (Math.random() - 0.5) * 30,
                        'feedback-node',
                        '360'
                    );
                    nodes.push(feedbackNode);
                    connections.push(new Connection(node, feedbackNode, 'feedback', 0.5));
                }
            });
            
            setTimeout(() => updateMetrics(35, 45, 50, 40), 100);
            }, 300);
        }

        // Phase 3: Values-Based Architecture (was Phase 2)
        function initPhase3() {
            // Animate the transition more smoothly
            setTimeout(() => {
                // Reorganize nodes around values
            const centerX = (canvas.displayWidth || canvas.width) / 2;
            const centerY = (canvas.displayHeight || canvas.height) / 2;
            
            // Create values hubs
            const values = ['Trust', 'Learning', 'Innovation', 'Empowerment'];
            const valueHubs = [];
            
            values.forEach((value, i) => {
                const angle = (Math.PI * 2 / values.length) * i;
                const x = centerX + Math.cos(angle) * 100;
                const y = centerY + Math.sin(angle) * 100;
                const hub = new Node(x, y, 'values-hub', value);
                nodes.push(hub);
                valueHubs.push(hub);
            });
            
            // Reorganize existing nodes around values
            nodes.forEach((node, index) => {
                if (node.type !== 'values-hub') {
                    const valueIndex = index % valueHubs.length;
                    const valueHub = valueHubs[valueIndex];
                    const angle = (Math.PI * 2 / 10) * (index % 10);
                    const radius = 80 + (node.type === 'leader' ? 0 : 40);
                    
                    node.targetX = valueHub.x + Math.cos(angle) * radius;
                    node.targetY = valueHub.y + Math.sin(angle) * radius;
                    
                    // Connect to value hub
                    connections.push(new Connection(node, valueHub, 'values', 0.4));
                }
            });
            
            // Add cross-functional connections based on shared values
            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    if (nodes[i].type !== 'values-hub' && nodes[j].type !== 'values-hub' &&
                        nodes[i].department !== nodes[j].department && Math.random() > 0.8) {
                        connections.push(new Connection(nodes[i], nodes[j], 'values', 0.3));
                    }
                }
            }
            
            setTimeout(() => updateMetrics(70, 75, 80, 70), 100);
            }, 500);
        }

        // Phase 4: High-EQ Communication
        function initPhase4() {
            // Animate the transition more smoothly
            setTimeout(() => {
                // Enhance all nodes with EQ capabilities
            nodes.forEach(node => {
                node.eqLevel = Math.random() * 0.5 + 0.5;
            });
            
            // Transform connections to high-quality EQ connections
            connections.forEach(conn => {
                if (conn.type === 'feedback' || conn.type === 'values') {
                    conn.strength = Math.min(conn.strength * 1.5, 1);
                }
            });
            
            // Add EQ-based connections for deeper collaboration
            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    if (nodes[i].eqLevel > 0.7 && nodes[j].eqLevel > 0.7 && Math.random() > 0.6) {
                        connections.push(new Connection(nodes[i], nodes[j], 'eq', 0.7));
                    }
                }
            }
            
            // Create innovation clusters around high-EQ nodes
            const highEQNodes = nodes.filter(n => n.eqLevel > 0.8);
            highEQNodes.forEach(node => {
                const nearby = nodes.filter(n => 
                    n !== node && 
                    Math.sqrt(Math.pow(n.x - node.x, 2) + Math.pow(n.y - node.y, 2)) < 150
                );
                nearby.forEach(n => {
                    connections.push(new Connection(node, n, 'eq', 0.5));
                });
            });
            
            setTimeout(() => updateMetrics(92, 95, 96, 91), 100);
            }, 700);
        }

        // Update metrics with staggered animation
        function updateMetrics(trust, collaboration, engagement, performance) {
            const metrics = [
                { id: 'trust', value: trust },
                { id: 'collaboration', value: collaboration },
                { id: 'engagement', value: engagement },
                { id: 'performance', value: performance }
            ];
            
            metrics.forEach((metric, index) => {
                setTimeout(() => {
                    const bar = document.getElementById(`${metric.id}Bar`);
                    const valueElement = document.getElementById(`${metric.id}Value`);
                    
                    if (!bar || !valueElement) {
                        console.error(`Elements not found for metric: ${metric.id}`);
                        return;
                    }
                    
                    // Animate the bar with a smooth transition
                    bar.style.transition = 'width 1.2s cubic-bezier(0.4, 0, 0.2, 1)';
                    bar.style.width = `${metric.value}%`;
                    
                    // Animate the value with a counter effect
                    const startValue = parseInt(valueElement.textContent.replace('%', '')) || 0;
                    const endValue = metric.value;
                    const duration = 1000;
                    const startTime = Date.now();
                    
                    function animateValue() {
                        const elapsed = Date.now() - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        const easedProgress = 1 - Math.pow(1 - progress, 3); // easeOutCubic
                        
                        const currentValue = Math.round(startValue + (endValue - startValue) * easedProgress);
                        valueElement.textContent = `${currentValue}%`;
                        
                        if (progress < 1) {
                            requestAnimationFrame(animateValue);
                        } else {
                            // Ensure final value is set correctly
                            valueElement.textContent = `${endValue}%`;
                        }
                    }
                    
                    requestAnimationFrame(animateValue);
                }, index * 100 + 300); // Stagger the animations
            });
        }

        // Animation loop
        function animate() {
            // Clear canvas with a light background
            ctx.fillStyle = '#fafafa';
            ctx.fillRect(0, 0, canvas.displayWidth || canvas.width, canvas.displayHeight || canvas.height);
            
            // Draw connections
            connections.forEach(conn => {
                conn.update();
                conn.draw();
            });
            
            // Draw feedback loops
            feedbackLoops.forEach(loop => {
                loop.draw();
            });
            
            // Draw particles
            particles = particles.filter(particle => {
                const alive = particle.update();
                if (alive) particle.draw();
                return alive;
            });
            
            // Draw nodes
            nodes.forEach(node => {
                node.update();
                node.draw();
            });
            
            time++;
            animationId = requestAnimationFrame(animate);
        }

        // Phase selection
        document.querySelectorAll('.phase-card').forEach(card => {
            card.addEventListener('click', function() {
                const phase = parseInt(this.dataset.phase);
                setPhase(phase);
            });
        });

        function setPhase(phase) {
            currentPhase = phase;
            document.querySelectorAll('.phase-card').forEach(card => {
                card.classList.remove('active');
            });
            document.querySelector(`[data-phase="${phase}"]`).classList.add('active');
            
            // Hide all overlays first
            document.getElementById('silosOverlay').classList.remove('visible');
            document.getElementById('feedbackOverlay').classList.remove('visible');
            document.getElementById('valuesOverlay').classList.remove('visible');
            document.getElementById('eqOverlay').classList.remove('visible');
            
            // Show appropriate overlay for current phase
            setTimeout(() => {
                if (phase === 1) {
                    document.getElementById('silosOverlay').classList.add('visible');
                } else if (phase === 2) {
                    document.getElementById('feedbackOverlay').classList.add('visible');
                } else if (phase === 3) {
                    document.getElementById('valuesOverlay').classList.add('visible');
                } else if (phase === 4) {
                    document.getElementById('eqOverlay').classList.add('visible');
                }
            }, 300);
            
            // Reset and build up to current phase
            initPhase1();
            
            if (phase >= 2) {
                setTimeout(() => initPhase2(), 200);
            }
            if (phase >= 3) {
                setTimeout(() => initPhase3(), 400);
            }
            if (phase >= 4) {
                setTimeout(() => initPhase4(), 600);
            }
        }

        // Play full animation with smoother transitions
        function playAnimation() {
            const button = document.querySelector('.play-button');
            button.disabled = true;
            button.textContent = '⏸ Playing Transformation...';
            
            setPhase(1);
            
            setTimeout(() => {
                setPhase(2);
                // Highlight the change
                document.querySelector('[data-phase="2"]').style.transform = 'scale(1.05)';
                setTimeout(() => {
                    document.querySelector('[data-phase="2"]').style.transform = '';
                }, 800);
            }, 3000);
            
            setTimeout(() => {
                setPhase(3);
                // Highlight the change
                document.querySelector('[data-phase="3"]').style.transform = 'scale(1.05)';
                setTimeout(() => {
                    document.querySelector('[data-phase="3"]').style.transform = '';
                }, 800);
            }, 6000);
            
            setTimeout(() => {
                setPhase(4);
                // Highlight the change
                document.querySelector('[data-phase="4"]').style.transform = 'scale(1.05)';
                setTimeout(() => {
                    document.querySelector('[data-phase="4"]').style.transform = '';
                }, 800);
            }, 9000);
            
            // Reset button after animation completes
            setTimeout(() => {
                button.disabled = false;
                button.textContent = '▶ View Complete Transformation';
            }, 12000);
        }

        // Initialize
        setTimeout(() => {
            resizeCanvas();
            initPhase1();
            // Show initial overlay
            document.getElementById('silosOverlay').classList.add('visible');
            animate();
        }, 100);
    </script>
</body>
</html>